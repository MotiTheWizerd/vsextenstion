/**
 * Modern Chat UI for RayDaemon
 * Handles chat interface interactions with a modern design similar to Kiro/Claude
 */

// Simple markdown to HTML converter
class MarkdownParser {
  static parse(text) {
    if (!text) {return "";}

    // Convert headers
    text = text.replace(/^### (.*$)/gm, "<h3>$1</h3>");
    text = text.replace(/^## (.*$)/gm, "<h2>$1</h2>");
    text = text.replace(/^# (.*$)/gm, "<h1>$1</h1>");

    // Convert code blocks
    text = text.replace(/```([\s\S]*?)```/g, (match, code) => {
      return `<pre><code>${this.escapeHtml(code.trim())}</code></pre>`;
    });

    // Convert inline code
    text = text.replace(/`([^`]+)`/g, "<code>$1</code>");

    // Convert links
    text = text.replace(
      /\[([^\]]+)\]\(([^)]+)\)/g,
      '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>'
    );

    // Convert bold and italic
    text = text.replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>");
    text = text.replace(/\*([^*]+)\*/g, "<em>$1</em>");
    // text = text.replace(/__([^_]+)__/g, "<strong>$1</strong>");
    // text = text.replace(/_([^_]+)_/g, "<em>$1</em>");

    // Convert lists
    text = text.replace(/^\s*[-*]\s+(.*$)/gm, "<li>$1</li>");
    text = text.replace(/(<li>.*<\/li>)/gs, "<ul>$1</ul>");

    // Convert line breaks
    text = text.replace(/\n/g, "<br>");

    return text;
  }

  static escapeHtml(unsafe) {
    return unsafe
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");
  }
}

class ModernChatUI {
  constructor() {
    this.chatInput = document.getElementById("chatInput");
    this.chatMessages = document.getElementById("chatMessages");
    this.sendButton = document.getElementById("sendButton");
    this.typingIndicator = document.getElementById("typingIndicator");
    this.statusBar = document.getElementById("statusBar");

    this.messageHistory = [];
    this.historyIndex = -1;
    this.typingTimeout = null;
    
    // Tool status tracking
    this.lastToolStatusTime = 0;

    this.initializeEventListeners();
    this.initializeUI();
    this.scrollToBottom();

    // Notify extension that webview is ready
    this.postMessage({ command: "webviewReady" });
  }

  initializeUI() {
    // Update the HTML structure to match modern design
    this.updateChatInputStructure();
    this.addWelcomeMessage();
  }

  updateChatInputStructure() {
    // Wrap the input in a modern container
    const inputContainer = this.chatInput.parentElement;
    if (!inputContainer.querySelector(".input-wrapper")) {
      const wrapper = document.createElement("div");
      wrapper.className = "input-wrapper";

      // Move input and button to wrapper
      wrapper.appendChild(this.chatInput);
      wrapper.appendChild(this.sendButton);

      inputContainer.appendChild(wrapper);
    }

    // Update send button with icon if not already done
    if (this.sendButton && !this.sendButton.querySelector(".send-icon")) {
      this.sendButton.innerHTML = `
        <div class="send-icon">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M22 2L11 13" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M22 2L15 22L11 13L2 9L22 2Z" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </div>
      `;
    }

    // Update typing indicator with dots
    if (
      this.typingIndicator &&
      !this.typingIndicator.querySelector(".typing-dots")
    ) {
      this.typingIndicator.innerHTML = `
        RayDaemon is thinking
        <div class="typing-dots">
          <span></span>
          <span></span>
          <span></span>
        </div>
      `;
    }

    // Update status bar with indicator
    if (this.statusBar && !this.statusBar.querySelector(".status-indicator")) {
      this.statusBar.innerHTML = `
        <div class="status-indicator"></div>
        <span>RayDaemon is ready</span>
      `;
    }
  }

  addWelcomeMessage() {
    this.addMessage(
      "assistant",
      `üëÅÔ∏è‚Äçüó®Ô∏è RayDaemon Initialized
      Modular intelligence mesh engaged. Task control loop online.<br>
      Say what you want. I‚Äôll route it. Plan it. Execute it.<br>
      üß† Sub-agents ready: Planner, Searcher, Architect<br><br>
      ‚û§ Ask anything. Or just say "status" to begin.<br>`,
      {
        isMarkdown: true,
        showAvatar: true,
      }
    );
  }

  postMessage(message) {
    vscode.postMessage(message);
  }

  initializeEventListeners() {
    // Send message on button click
    this.sendButton.addEventListener("click", () => this.handleSendMessage());

    // Handle keyboard events
    this.chatInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        this.handleSendMessage();
        return;
      }

      if (e.key === "ArrowUp" || e.key === "ArrowDown") {
        this.navigateHistory(e.key === "ArrowUp" ? "up" : "down");
        e.preventDefault();
        return;
      }

      if (e.key.length === 1 || e.key === "Backspace" || e.key === "Delete") {
        this.historyIndex = -1;
      }
    });

    // Auto-resize textarea and ensure proper width
    this.chatInput.addEventListener("input", () => {
      this.adjustTextareaHeight();
      this.updateSendButton();
      this.ensureInputWidth();
    });

    // Handle paste events
    this.chatInput.addEventListener("paste", (e) => {
      this.handlePaste(e);
    });

    // Focus input when clicking in chat area (but not on interactive elements)
    this.chatMessages.addEventListener("click", (e) => {
      // Don't focus input if clicking on interactive elements
      if (e.target.closest('.tool-count, .tool-file-item, .copy-button, a, button')) {
        return;
      }
      this.chatInput.focus();
    });

    // Handle window resize to maintain input width
    window.addEventListener("resize", () => {
      this.ensureInputWidth();
      this.adjustTextareaHeight();
    });

    // Ensure input stretches on focus
    this.chatInput.addEventListener("focus", () => {
      this.ensureInputWidth();
    });
  }

  updateSendButton() {
    const hasText = this.chatInput.value.trim().length > 0;
    this.sendButton.disabled = !hasText;
  }

  handleSendMessage() {
    const message = this.chatInput.value.trim();
    if (!message) {return;}

    // Add user message with avatar
    this.addMessage("user", message, { showAvatar: true });

    // Clear input
    this.chatInput.value = "";
    this.adjustTextareaHeight();
    this.updateSendButton();

    // Show typing indicator
    this.showTypingIndicator(true);

    // Add to history
    this.messageHistory.push(message);
    if (this.messageHistory.length > 50) {
      this.messageHistory.shift();
    }

    try {
      this.postMessage({
        type: "chat",
        content: message,
      });

      // Timeout for typing indicator
      this.typingTimeout = setTimeout(() => {
        this.showTypingIndicator(false);
        this.addMessage(
          "assistant",
          "Sorry, I didn't receive a response. Please try again.",
          {
            isMarkdown: false,
            showAvatar: true,
          }
        );
      }, 30000);
    } catch (error) {
      console.error("Error sending message:", error);
      this.showTypingIndicator(false);
      this.addMessage(
        "assistant",
        "Failed to send message. Please try again.",
        {
          isMarkdown: false,
          showAvatar: true,
        }
      );
    }
  }

  addMessage(sender, content, options = {}) {
    const {
      timestamp = new Date(),
      isMarkdown = true,
      showAvatar = false,
      replaceLast = false,
      isWorking = false,
      isToolMessage = false,
    } = options;

    if (replaceLast) {
      const lastMessage = this.chatMessages.lastElementChild;
      if (lastMessage && lastMessage.classList.contains("message")) {
        lastMessage.remove();
      }
    }

    // Always clear typing indicator when adding any message
    this.showTypingIndicator(false);
    if (this.typingTimeout) {
      clearTimeout(this.typingTimeout);
      this.typingTimeout = null;
    }

    const messageDiv = document.createElement("div");
    messageDiv.className = `message ${sender}`;
    
    // Mark working messages for easy identification
    if (isWorking) {
      messageDiv.setAttribute('data-working', 'true');
    }
    
    // Mark tool messages for special styling
    if (isToolMessage) {
      messageDiv.classList.add('tool-message');
    }

    // Add avatar if requested (not for tool messages)
    if (showAvatar && !isToolMessage) {
      const avatar = document.createElement("div");
      avatar.className = "message-avatar";
      avatar.textContent = sender === "user" ? "U" : "R";
      messageDiv.appendChild(avatar);
    }

    // Create message content
    const contentDiv = document.createElement("div");
    contentDiv.className = "message-content";

    if (isMarkdown && content) {
      contentDiv.innerHTML = MarkdownParser.parse(content);
    } else {
      contentDiv.textContent = content || "";
    }

    messageDiv.appendChild(contentDiv);

    // Add timestamp (only for non-tool messages)
    if (!isToolMessage) {
      const timeDiv = document.createElement("div");
      timeDiv.className = "message-time";
      timeDiv.textContent = timestamp.toLocaleTimeString([], {
        hour: "2-digit",
        minute: "2-digit",
      });
      contentDiv.appendChild(timeDiv);
    }

    // Add copy buttons to code blocks
    contentDiv.querySelectorAll("pre").forEach((pre) => {
      const copyButton = document.createElement("button");
      copyButton.className = "copy-button";
      copyButton.innerHTML = "üìã";
      copyButton.title = "Copy code";
      copyButton.addEventListener("click", () => {
        const code = pre.querySelector("code")?.textContent || "";
        navigator.clipboard.writeText(code).then(() => {
          copyButton.textContent = "‚úì";
          setTimeout(() => {
            copyButton.innerHTML = "üìã";
          }, 2000);
        });
      });
      pre.appendChild(copyButton);
    });

    this.chatMessages.appendChild(messageDiv);
    this.scrollToBottom();

    return messageDiv;
  }

  handleToolStatus(data) {
    const { status, tools, successCount, failedCount, totalCount, error, results } = data;
    
    console.log('handleToolStatus called with:', data);
    
    let content = '';
    let className = 'tool-status';

    if (status === 'working') {
      // Show detailed working status with tool information
      const toolInfo = this.getDetailedToolInfo(tools);
      content = `<div class="${className} working" data-tool-id="current-working">
        <div class="tool-icon">${toolInfo.icon}</div>
        <div class="tool-content">
          <div class="tool-title">RayDaemon is thinking...</div>
          <div class="tool-details">${toolInfo.description}</div>
        </div>
        <div class="tool-meta">
          <div class="tool-spinner"></div>
        </div>
      </div>`;
      
      // Remove only the current working indicator if it exists
      const existingWorking = this.chatMessages.querySelector('[data-tool-id="current-working"]');
      if (existingWorking) {
        existingWorking.remove();
      }
    } else if (status === 'completed') {
      // Remove the working indicator
      const workingIndicator = this.chatMessages.querySelector('[data-tool-id="current-working"]');
      if (workingIndicator) {
        workingIndicator.remove();
      }
      
      // Create detailed completion message based on tools used
      const toolInfo = this.getDetailedCompletionInfo(tools, results, totalCount);
      
      // Generate a unique ID for this completion message to avoid duplicates
      const completionId = `batch-completed-${Date.now()}`;
      
      // Check if we have file results to show
      const hasFileResults = this.hasFileResults(results);
      const dropdownHtml = hasFileResults ? this.createFileDropdown(results, totalCount) : '';
      
      if (failedCount > 0 && successCount === 0) {
        // All failed - use red failed styling
        content = `<div class="${className} failed" data-tool-id="${completionId}">
          <div class="tool-icon">üí•</div>
          <div class="tool-content">
            <div class="tool-title">${toolInfo.title}</div>
            <div class="tool-details">${toolInfo.details} ‚Ä¢ ${failedCount} error${failedCount > 1 ? 's' : ''}</div>
          </div>
          <div class="tool-meta">
            <div class="tool-count ${hasFileResults ? 'expandable' : ''}" data-expandable="${hasFileResults}">${failedCount} error${failedCount > 1 ? 's' : ''}</div>
          </div>
          ${dropdownHtml}
        </div>`;
      } else if (failedCount > 0) {
        // Some failed, some succeeded - use yellow partial styling
        content = `<div class="${className} partial" data-tool-id="${completionId}">
          <div class="tool-icon">‚ö†Ô∏è</div>
          <div class="tool-content">
            <div class="tool-title">${toolInfo.title}</div>
            <div class="tool-details">${toolInfo.details} ‚Ä¢ ${failedCount} error${failedCount > 1 ? 's' : ''}</div>
          </div>
          <div class="tool-meta">
            <div class="tool-count ${hasFileResults ? 'expandable' : ''}" data-expandable="${hasFileResults}">${successCount}/${totalCount}</div>
          </div>
          ${dropdownHtml}
        </div>`;
      } else {
        content = `<div class="${className} success" data-tool-id="${completionId}">
          <div class="tool-icon">${toolInfo.icon}</div>
          <div class="tool-content">
            <div class="tool-title">${toolInfo.title}</div>
            <div class="tool-details">${toolInfo.details}</div>
          </div>
          <div class="tool-meta">
            <div class="tool-count ${hasFileResults ? 'expandable' : ''}" data-expandable="${hasFileResults}">${totalCount} result${totalCount > 1 ? 's' : ''}</div>
          </div>
          ${dropdownHtml}
        </div>`;
      }
    } else if (status === 'failed') {
      // Remove the working indicator
      const workingIndicator = this.chatMessages.querySelector('[data-tool-id="current-working"]');
      if (workingIndicator) {
        workingIndicator.remove();
      }
      
      content = `<div class="${className} failed">
        <div class="tool-icon">üí•</div>
        <div class="tool-content">
          <div class="tool-title">Tool execution failed</div>
          <div class="tool-details">An error occurred during execution</div>
        </div>
      </div>`;
    }

    if (content) {
      const messageDiv = document.createElement("div");
      messageDiv.className = "message system tool-message";
      messageDiv.innerHTML = content;
      
      // Add click handler for expandable tool counts
      const expandableCount = messageDiv.querySelector('.tool-count.expandable');
      if (expandableCount) {
        expandableCount.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
          this.toggleToolDropdown(messageDiv);
        });
      }
      
      this.chatMessages.appendChild(messageDiv);
      this.scrollToBottom();
    }
  }

  getDetailedToolInfo(tools) {
    if (!tools || tools.length === 0) {
      return { icon: 'üîß', description: 'Processing request...' };
    }

    const toolNames = tools.map(t => t.toLowerCase());
    
    if (toolNames.some(t => t.includes('reading'))) {
      return { icon: 'üìñ', description: 'Reading and analyzing files...' };
    } else if (toolNames.some(t => t.includes('searching') || t.includes('finding'))) {
      return { icon: 'üîç', description: 'Searching through codebase...' };
    } else if (toolNames.some(t => t.includes('writing') || t.includes('creating'))) {
      return { icon: '‚úèÔ∏è', description: 'Creating and writing files...' };
    } else if (toolNames.some(t => t.includes('index'))) {
      return { icon: 'üìö', description: 'Building symbol index...' };
    } else if (toolNames.some(t => t.includes('diagnostic'))) {
      return { icon: 'üî¨', description: 'Analyzing code diagnostics...' };
    } else if (toolNames.some(t => t.includes('listing'))) {
      return { icon: 'üìã', description: 'Listing directory contents...' };
    } else {
      return { icon: '‚ö°', description: `Executing ${tools.length} tool${tools.length > 1 ? 's' : ''}...` };
    }
  }

  getDetailedCompletionInfo(tools, results = [], totalCount) {
    if (!tools || tools.length === 0) {
      return { 
        icon: '‚úÖ', 
        title: 'Task completed', 
        details: 'Operation finished successfully' 
      };
    }

    // Try to use detailed results for more specific messages
    if (results && results.length > 0) {
      try {
        const primaryResult = results[0];
        const command = primaryResult.command;
        const args = primaryResult.args || [];
        
        switch (command) {
          case 'read':
            const fileName = args[0] ? args[0].split(/[/\\]/).pop() : 'file';
            const fileSize = primaryResult.outputLength ? `${Math.round(primaryResult.outputLength / 1024)}KB` : '';
            return { 
              icon: 'üìÑ', 
              title: `Read ${fileName}`, 
              details: fileSize ? `File content loaded ‚Ä¢ ${fileSize}` : 'File content loaded'
            };
          case 'findByExtension':
            const ext = args[0] || 'files';
            return { 
              icon: 'üîç', 
              title: `Found ${ext} files`, 
              details: `Located ${totalCount} matching file${totalCount > 1 ? 's' : ''}`
            };
          case 'searchText':
          case 'searchRegex':
            const searchTerm = args[0] || 'text';
            const shortTerm = searchTerm.length > 20 ? searchTerm.substring(0, 20) + '...' : searchTerm;
            return { 
              icon: 'üîé', 
              title: `Searched for "${shortTerm}"`, 
              details: `Found ${totalCount} match${totalCount > 1 ? 'es' : ''} in codebase`
            };
          case 'findSymbol':
          case 'findSymbolFromIndex':
            const symbolName = args[0] || 'symbol';
            return { 
              icon: 'üéØ', 
              title: `Found symbol ${symbolName}`, 
              details: `Located ${totalCount} reference${totalCount > 1 ? 's' : ''}`
            };
          case 'createIndex':
            return { 
              icon: 'üìö', 
              title: 'Created symbol index', 
              details: `Indexed ${totalCount} symbol${totalCount > 1 ? 's' : ''} from codebase`
            };
          case 'loadIndex':
            return { 
              icon: 'üìñ', 
              title: 'Loaded symbol index', 
              details: `Index ready with ${totalCount} symbol${totalCount > 1 ? 's' : ''}`
            };
          case 'write':
            const writeFile = args[0] ? args[0].split(/[/\\]/).pop() : 'file';
            return { 
              icon: 'üíæ', 
              title: `Created ${writeFile}`, 
              details: 'File written successfully'
            };
          case 'getAllDiagnostics':
            return { 
              icon: 'üî¨', 
              title: 'Analyzed diagnostics', 
              details: `Found ${totalCount} issue${totalCount > 1 ? 's' : ''} across workspace`
            };
          default:
            return { 
              icon: '‚ö°', 
              title: `Executed ${command}`, 
              details: `Operation completed with ${totalCount} result${totalCount > 1 ? 's' : ''}`
            };
        }
      } catch (e) {
        console.warn('Error processing detailed results:', e);
      }
    }
    
    // Fallback logic based on tool names
    const toolTypes = tools.map(tool => tool.toLowerCase());
    
    if (toolTypes.some(t => t.includes('find') || t.includes('symbol'))) {
      return { icon: 'üéØ', title: 'Found symbols', details: `Located ${totalCount} result${totalCount > 1 ? 's' : ''}` };
    } else if (toolTypes.some(t => t.includes('read'))) {
      return { icon: 'üìÑ', title: 'Read files', details: `Processed ${totalCount} file${totalCount > 1 ? 's' : ''}` };
    } else if (toolTypes.some(t => t.includes('index'))) {
      return { icon: 'üìö', title: 'Updated index', details: `Processed ${totalCount} item${totalCount > 1 ? 's' : ''}` };
    } else if (toolTypes.some(t => t.includes('diagnostic'))) {
      return { icon: 'üî¨', title: 'Analyzed diagnostics', details: `Found ${totalCount} issue${totalCount > 1 ? 's' : ''}` };
    } else {
      return { icon: '‚úÖ', title: 'Task completed', details: `${totalCount} operation${totalCount > 1 ? 's' : ''} finished` };
    }
  }

  handleIncomingMessage(message) {
    console.log("Received message:", message);

    // Clear typing indicator and timeout for any incoming response
    if (this.typingTimeout) {
      clearTimeout(this.typingTimeout);
      this.typingTimeout = null;
    }
    this.showTypingIndicator(false);

    // Handle tool status messages
    if (message.type === "toolStatus" && message.data) {
      this.handleToolStatus(message.data);
      return;
    }

    // Handle different message types
    if (message.type === "chat_response") {
      this.addMessage("assistant", message.content, {
        isMarkdown: true,
        showAvatar: true,
      });
      return;
    }

    if (message.type === "rayResponse" && message.data) {
      const { content, isWorking, isFinal, isCommandResult } = message.data;
      if (content && !isCommandResult) { // Skip old command result messages
        // If this is a final response and we have a working message, replace it
        if (isFinal !== false && !isWorking) {
          const workingMessage = this.chatMessages.querySelector('[data-working="true"]');
          if (workingMessage) {
            workingMessage.remove();
          }
        }
        
        this.addMessage("assistant", content, {
          isMarkdown: true,
          showAvatar: true,
          isWorking: isWorking || false,
        });
      }
      return;
    }

    // Handle command-based messages
    if (message.command) {
      switch (message.command) {
        case "addMessage":
          this.addMessage(message.sender, message.content, {
            ...message.options,
            showAvatar: true,
          });
          break;
        case "showTyping":
          this.showTypingIndicator(message.typing);
          break;
        case "clearChat":
          this.clearChat();
          break;
        case "setStatus":
          this.setStatus(message.status);
          break;
        case "chatError":
          this.addMessage("assistant", `Error: ${message.error}`, {
            isMarkdown: false,
            showAvatar: true,
          });
          break;
      }
    }
  }

  navigateHistory(direction) {
    if (this.messageHistory.length === 0) {return;}

    if (
      direction === "up" &&
      this.historyIndex < this.messageHistory.length - 1
    ) {
      this.historyIndex++;
    } else if (direction === "down" && this.historyIndex >= 0) {
      this.historyIndex--;
    } else {
      return;
    }

    const message =
      this.historyIndex >= 0
        ? this.messageHistory[
            this.messageHistory.length - 1 - this.historyIndex
          ]
        : "";

    this.chatInput.value = message;
    this.adjustTextareaHeight();
    this.updateSendButton();
  }

  showTypingIndicator(show) {
    if (this.typingTimeout) {
      clearTimeout(this.typingTimeout);
    }

    this.typingIndicator.classList.toggle("show", show);
    if (show) {
      this.scrollToBottom();
    }
  }

  handlePaste(event) {
    const items = (event.clipboardData || event.originalEvent.clipboardData)
      .items;

    for (const item of items) {
      if (item.kind === "file") {
        const file = item.getAsFile();
        if (file) {
          this.handleFileUpload(file);
          event.preventDefault();
          return;
        }
      }
    }
  }

  handleFileUpload(file) {
    const reader = new FileReader();

    reader.onload = (e) => {
      this.postMessage({
        command: "fileUpload",
        filename: file.name,
        type: file.type,
        size: file.size,
        content: e.target.result,
      });
    };

    reader.readAsDataURL(file);
  }

  clearChat() {
    this.chatMessages.innerHTML = "";
    this.addWelcomeMessage();
  }

  setStatus(status) {
    const statusText = this.statusBar?.querySelector("span");
    if (statusText) {
      statusText.textContent = status;
    }
  }

  adjustTextareaHeight() {
    this.chatInput.style.height = "auto";
    this.chatInput.style.height =
      Math.min(this.chatInput.scrollHeight, 120) + "px";
  }

  ensureInputWidth() {
    // Ensure the input takes full available width
    const inputWrapper = this.chatInput.parentElement;
    if (inputWrapper && inputWrapper.classList.contains("input-wrapper")) {
      const sendButtonWidth = this.sendButton.offsetWidth;
      const gap = 12; // Gap between input and button
      const containerPadding = 48; // Total horizontal padding
      
      const availableWidth = inputWrapper.offsetWidth - sendButtonWidth - gap - containerPadding;
      this.chatInput.style.width = `${Math.max(availableWidth, 200)}px`;
    }
  }

  scrollToBottom() {
    setTimeout(() => {
      this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
    }, 10);
  }

  focusInput() {
    this.chatInput?.focus();
    this.ensureInputWidth();
  }

  hasFileResults(results) {
    if (!results || results.length === 0) {return false;}
    
    // Check if any result contains file paths or file-related output
    return results.some(result => {
      if (!result.ok || !result.output) {return false;}
      
      const command = result.command;
      const output = result.output;
      
      // Commands that typically return file paths
      if (['findByExtension', 'ls', 'searchText', 'searchRegex', 'findSymbol', 'findSymbolFromIndex'].includes(command)) {
        return true;
      }
      
      // Check if output contains file paths (simple heuristic)
      if (typeof output === 'string' && (output.includes('/') || output.includes('\\'))) {
        return true;
      }
      
      // Check if output is an array of file paths
      if (Array.isArray(output) && output.length > 0) {
        return output.some(item => typeof item === 'string' && (item.includes('/') || item.includes('\\')));
      }
      
      return false;
    });
  }

  createFileDropdown(results, totalCount) {
    const files = this.extractFileList(results);
    if (files.length === 0) {return '';}
    
    const displayFiles = files.slice(0, 10); // Show max 10 files
    const hasMore = files.length > 10;
    
    const fileItems = displayFiles.map(file => {
      const icon = this.getFileIcon(file);
      const fileName = file.split(/[/\\]/).pop() || file;
      const filePath = file.length > fileName.length ? file.substring(0, file.length - fileName.length - 1) : '';
      
      return `
        <div class="tool-file-item" data-file-path="${file}">
          <div class="tool-file-icon">${icon}</div>
          <div class="tool-file-name">${fileName}</div>
          ${filePath ? `<div class="tool-file-path">${filePath}</div>` : ''}
        </div>
      `;
    }).join('');
    
    const moreIndicator = hasMore ? `<div class="tool-more-indicator">... and ${files.length - 10} more files</div>` : '';
    
    return `
      <div class="tool-dropdown">
        <div class="tool-file-list">
          ${fileItems}
          ${moreIndicator}
        </div>
      </div>
    `;
  }

  extractFileList(results) {
    const files = new Set();
    
    results.forEach(result => {
      if (!result.ok || !result.output) {return;}
      
      const output = result.output;
      
      if (typeof output === 'string') {
        // Split by newlines and filter for file paths
        const lines = output.split('\n').map(line => line.trim()).filter(line => line);
        lines.forEach(line => {
          if (line.includes('/') || line.includes('\\')) {
            // Remove any leading/trailing quotes or whitespace
            const cleanPath = line.replace(/^["']|["']$/g, '').trim();
            if (cleanPath) {files.add(cleanPath);}
          }
        });
      } else if (Array.isArray(output)) {
        output.forEach(item => {
          if (typeof item === 'string' && (item.includes('/') || item.includes('\\'))) {
            files.add(item);
          }
        });
      }
    });
    
    return Array.from(files).sort();
  }

  getFileIcon(filePath) {
    const fileName = filePath.split(/[/\\]/).pop() || '';
    const extension = fileName.split('.').pop()?.toLowerCase() || '';
    
    // File type icons
    const iconMap = {
      'js': 'üìÑ',
      'ts': 'üìò',
      'jsx': '‚öõÔ∏è',
      'tsx': '‚öõÔ∏è',
      'html': 'üåê',
      'css': 'üé®',
      'scss': 'üé®',
      'sass': 'üé®',
      'json': 'üìã',
      'md': 'üìù',
      'txt': 'üìÑ',
      'py': 'üêç',
      'java': '‚òï',
      'cpp': '‚öôÔ∏è',
      'c': '‚öôÔ∏è',
      'php': 'üêò',
      'rb': 'üíé',
      'go': 'üêπ',
      'rs': 'ü¶Ä',
      'vue': 'üíö',
      'xml': 'üìÑ',
      'yml': '‚öôÔ∏è',
      'yaml': '‚öôÔ∏è',
      'png': 'üñºÔ∏è',
      'jpg': 'üñºÔ∏è',
      'jpeg': 'üñºÔ∏è',
      'gif': 'üñºÔ∏è',
      'svg': 'üé®',
      'pdf': 'üìï',
      'zip': 'üì¶',
      'tar': 'üì¶',
      'gz': 'üì¶'
    };
    
    // Check if it's a directory (no extension or ends with /)
    if (!extension || filePath.endsWith('/') || filePath.endsWith('\\')) {
      return 'üìÅ';
    }
    
    return iconMap[extension] || 'üìÑ';
  }

  toggleToolDropdown(messageDiv) {
    console.log('toggleToolDropdown called'); // Debug log
    
    const dropdown = messageDiv.querySelector('.tool-dropdown');
    const countElement = messageDiv.querySelector('.tool-count.expandable');
    
    console.log('dropdown:', dropdown, 'countElement:', countElement); // Debug log
    
    if (!dropdown || !countElement) {
      console.log('Missing dropdown or countElement'); // Debug log
      return;
    }
    
    const isExpanded = dropdown.classList.contains('expanded');
    console.log('isExpanded:', isExpanded); // Debug log
    
    if (isExpanded) {
      dropdown.classList.remove('expanded');
      countElement.classList.remove('expanded');
      console.log('Collapsed dropdown'); // Debug log
    } else {
      dropdown.classList.add('expanded');
      countElement.classList.add('expanded');
      console.log('Expanded dropdown'); // Debug log
      
      // Add click handlers to file items
      const fileItems = dropdown.querySelectorAll('.tool-file-item');
      fileItems.forEach(item => {
        item.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const filePath = item.dataset.filePath;
          if (filePath) {
            this.openFile(filePath);
          }
        });
      });
    }
    
    // Scroll to keep the dropdown in view
    setTimeout(() => {
      this.scrollToBottom();
    }, 300);
  }

  openFile(filePath) {
    // Send message to extension to open the file
    this.postMessage({
      type: 'openFile',
      filePath: filePath
    });
  }
}

// Initialize when DOM is ready
document.addEventListener("DOMContentLoaded", () => {
  const chatUI = new ModernChatUI();

  // Listen for messages from extension
  window.addEventListener("message", (event) => {
    try {
      chatUI.handleIncomingMessage(event.data);
    } catch (error) {
      console.error("Error handling message:", error);
    }
  });

  // Handle page unload
  window.addEventListener("beforeunload", () => {
    chatUI.postMessage({ command: "webviewUnload" });
  });

  // Focus input after initialization and ensure proper sizing
  setTimeout(() => {
    chatUI.focusInput();
    chatUI.ensureInputWidth();
  }, 100);
});

// Initialize when DOM is ready
document.addEventListener("DOMContentLoaded", () => {
  const chatUI = new ModernChatUI();

  // Listen for messages from extension
  window.addEventListener("message", (event) => {
    try {
      chatUI.handleIncomingMessage(event.data);
    } catch (error) {
      console.error("Error handling message:", error);
    }
  });

  // Handle page unload
  window.addEventListener("beforeunload", () => {
    chatUI.postMessage({ command: "webviewUnload" });
  });

  // Focus input after initialization and ensure proper sizing
  setTimeout(() => {
    chatUI.focusInput();
    chatUI.ensureInputWidth();
  }, 100);
});
ment = messageDiv.querySelector('.tool-count.expandable');
    
    console.log('toggleToolDropdown called'); // Debug log
    console.log('dropdown:', dropdown, 'countElement:', countElement); // Debug log
    
    if (!dropdown || !countElement) {
      console.log('Missing dropdown or countElement'); // Debug log
      return;
    }
    
    const isExpanded = dropdown.classList.contains('expanded');
    console.log('isExpanded:', isExpanded); // Debug log
    
    if (isExpanded) {
      dropdown.classList.remove('expanded');
      countElement.classList.remove('expanded');
      console.log('Collapsed dropdown'); // Debug log
    } else {
      dropdown.classList.add('expanded');
      countElement.classList.add('expanded');
      console.log('Expanded dropdown'); // Debug log
      
      // Add click handlers to file items
      const fileItems = dropdown.querySelectorAll('.tool-file-item');
      fileItems.forEach(item => {
        item.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const filePath = item.dataset.filePath;
          if (filePath) {
            this.openFile(filePath);
          }
        });
      });
    }
    
    // Scroll to keep the dropdown in view
    setTimeout(() => {
      this.scrollToBottom();
    }, 300);
  }

  openFile(filePath) {
    // Send message to extension to open the file
    this.postMessage({
      type: 'openFile',
      filePath: filePath
    });
  }
}

// Initialize when DOM is ready
document.addEventListener("DOMContentLoaded", () => {
  const chatUI = new ModernChatUI();

  // Listen for messages from extension
  window.addEventListener("message", (event) => {
    try {
      chatUI.handleIncomingMessage(event.data);
    } catch (error) {
      console.error("Error handling message:", error);
    }
  });

  // Handle page unload
  window.addEventListener("beforeunload", () => {
    chatUI.postMessage({ command: "webviewUnload" });
  });

  // Focus input after initialization and ensure proper sizing
  setTimeout(() => {
    chatUI.focusInput();
    chatUI.ensureInputWidth();
  }, 100);
});});
